# Laravel collections шпаргалка

> Любительская шпаргалка к функциям Laravel Collections

## Зачем все это...
Эта шпаргалка была написана в течение просмотра [курса по коллекциям](https://www.youtube.com/watch?v=EES3xrcB9RA) от [LaravelCreative](https://www.youtube.com/@laravelcreative)

Особенностью данной шпаргалки является разбивка функций по категориям, что облегчит поиск нужной функции
(В официальной документации функции идут в алфавитном порядке, но вперемешку по назначению)

## Категории

> Все функции в данной документации будут делиться на следующие категории:
> 1. Получения и проверки - когда мы хотим что-либо достать из коллекции, или проверить наличие чего-либо в ней
> 2. Преобразования - когда мы хотим изменить коллекцию каким-либо образом
> 3. Математические функции

### Функции "Получения и проверки"

```php
$collection->all(); // Отдает все что в коллекции преобразовывая в массив
```
```php
$collection->contains($value); // Проверяет наличие элемента в коллекции,
// может принимать замыкание с условием (подходит для моделей)
$collection->contains($key, $value); // Подходит для моделей
$collection->contains(function($model) {...});  // Подходит для моделей
```
```php
$collection->doesntContain($value) // То же самое что и contains(), только наоборот
```
```php
$collection->containsStrict($value);  // Строгая типизация искомого значения
```
```php
$collection->containsOneItem(); // Проверка на содержание только одного элемента
```
```php
$collection->count(); // Подсчет кол-ва элементов в коллекции
```
```php
$collection->countBy(function($item) {...});
// Подсчитывает элементы по условию, затем возвращает коллекцию
// с кол-вами элементов которые попали и не попали под условие
```
```php
$collection->dd(); // Дамп коллекции с преобразованием в массив
```
```php
$collection->diff($collection2); // Возвращает элементы из первой коллекции, которых нет во второй
```
```php
$collection->diffAssoc($collection2);
// Возвращает элементы из первой коллекции, которых нет во второй по ЗНАЧЕНИЯМ в ассоциативных массивах
```
```php
$collection->diffKeys($collection2);
// Возвращает элементы из первой коллекции, которых нет во второй по КЛЮЧАМ в ассоциативных массивах
```
```php
$collection->duplicates(); // Возвращает все дубликаты в коллекции с ключами дублирующихся элементов
// Смотрит на полное соответствие элементов, если не указан ключ по которому искать (для ассоциативных)
```
```php
$collection->duplicatesStrict(); // То же самое что и duplicates(), но строгое сравнение дубликатов
```
```php
$collection->every(); // Позволяет определить, все ли элементы коллекции соответствуют условию в closure
```
```php
$collection->forPage(int $page, int $perPage); // Для пагинации
```
```php
$collection->get($key, optional $default); // Получение значения по ключу
$collection->get($key, function() {...}); // Значение по умолчанию в closure
```
```php
$collection->has($key); // То же, что и contains(), но ищет по ключу. Возрващает bool
$collection->has(array $keys); // Может принимать массив ключей,
// но в таком случае проверяет наличие всех переданных ключей

$collection->hasAny(array $keys);
// Работает как has, только вместо наличия всех ключей проверяет наличие хотя бы одного ключа
```
```php
$collection->intersect($collection2); // Возвращает коллекцию с совпавшими элементами двух коллекций
$collection->intersectAssoc($collection2); // Возвращает коллекцию с совпавшими значениями двух ассоциативных коллекций
$collection->intersectByKeys($collection2); // Возвращает коллекцию с совпавшими ключами двух ассоциативных коллекций
```
```php
$collection->isEmpty(); // Проверка коллекции на пустоту
$collection->isNotEmpty(); // Проверка коллекции на !пустоту
```
```php
$collection->keys(); // Позволяет получить все имеющиеся в коллекции ключи
```
```php
$collection->pluck($value, $key); // Позволяет получить какие-то конкретные значения
// элементов коллекции (для моделей - колонки из бд)
// Так же позволяет задать $key для полученных элементов (можно задать колонку из бд в моделях)
// При совпадении ключей меняет на последний найденный элемент
$collection->pluck('element.subElement'); // Поддерживает вложенность
```
```php
$collection->random($n); // Возвращает коллекцию с $n рандомных элементов исходной коллекции
```
```php
$collection->search($value, optional $strict); // Ищем $value в коллекции, получаем ключ элемента
// Можно указать параметр $strict для строгого сравнения
$collection->search(function($item) {...}); // Можно использовать замыкания
```
```php
$collection->sole(function($item) {...}); // Возвращает элемент из коллекции, соблюдающий условие в closure,
// но только если он является НЕПОВТОРИМЫМ элементом в этой коллекции
// В случае, если найдется 2 элемента, которые подходят под условие в closure,
// выкинется MultipleItemsFoundException
$collection->sole($key, $value); // Также, поддерживает поиск по ключ-значению
```
```php
$collecion->some(); // Alias для contains() метода.
```
```php
$collection->value($key); // Возвращает значения первого элемента коллекции по ключу
```
```php
$collection->values(); // Возвращает новую коллекцию, но отсчет ключей идет с 0
```
```php
$collection->where($key, $operator, $value); // То же, что и where() в Eloquent ORM
$collection->whereStrict($key, $operator, $value); // Строгое where()
$collection->whereBetween($key, array $values) // Поиск where между значениями в $values
$collection->whereNotBetween($key, array $values) // Поиск where НЕ между значениями в $values
$collection->whereIn($key, array $values) // Поиск where значений $values
$collection->whereNotIn($key, array $values) // Поиск where значений не соответствующих $values
$collection->whereInStrict($key, $operator, $value); // Строгое whereIn()
$collection->whereNotInStrict($key, $operator, $value); // Строгое whereNotIn()
$collection->whereInstanceOf(SomeClass::class); // Поиск where по признаку класса объектов в коллекции
$collection->whereNull(); // Возвращает все NULL элементы
// Можно прокинуть $key по которому будет поиск NULL элементов
$collection->whereNotNull(); // Возвращает все не NULL элементы
```
```php
$collection->take(int $n); // Возвращает первые $n элементов коллекции
// Чтобы взять элементы с конца массива, необходимо указать отрицательное $n
$collection->takeUntil(function() {...}); // Возвращает элементы до тех пор,
// пока условие в closure НЕ соблюдается
$collection->takeWhile(function() {...}); // Возвращает элементы до тех пор,
// пока условие в closure соблюдается
```
```php
$collection->tap(function(Collection $collection) {...}); // Позволяет обратиться к какому-либо классу в closure
// для сохранения цепочки преобразований коллекции
// Пример: для логирования чего-либо внутри цепочки
```
```php
$collection->unique(optional $key); // Возвращает коллекцию уникальных значений исходной коллекции
// При указанном ключе $key определяет уникальность по заданному ключу (вложенные ассоциативные массивы)
$collection->unique(function() {...}); // Позволяет определять уникальность по составным ключам
$collection->uniqueStrict(); // То же, что и unique(), только со строгим сравнением
```


### Функции "Преобразования"

```php
$collection->chunk($count); // Разбивает коллекцию по подколлекциям с кол-вом $count
```

```php
$collection->chunkWhile(function($value, $key, $collection) {...});
// Разбивает коллекцию по подколлекциям при условии while,
// при первом несоответствии разбивает в новую коллекцию
```
```php
$collection->collapse(); // Убирает вложеноость массивов
```
```php
$collection->combine($collection2);
// Первый массив становится ключами, а второй - значениями
// Склеивает коллекции в ассоциативный массив, при несоответствии кол-ва элементов - ошибка
```
```php
$collection->concat($array); // Объединяет коллекцию с массивом (или с коллекцией)
// Объединяет НЕ ассоциативно, для ассоциативного объединения есть merge()
```
```php
$collection->crossJoin($collection2);
// Создает новую коллекцию, в которой соединяет каждый элемент одной коллекции с каждым элементом другой
```
```php
$collection->each(function($item) {}); // Foreach
$collection->eachSpread(); // Тот же foreach, но итерируется по вложенным элементам в closure
// Не меняет исходную коллекцию, не возвращает измененную коллекцию... (в отличие от mapSpread)
// Остановить итерацию - return false
```
```php
$collection->except(array $keys); // Возвращает коллекцию БЕЗ указаных ключей
```
```php
$collection->only(array $keys); // Возвращает коллекцию ТОЛЬКО с указаными ключами
```
```php
$collection->filter(function($item) {}); // Фильтрует коллекцию по условию в closure, оставляет элементы при true
$collection->reject(function($item) {}); // Фильтрует коллекцию по условию в closure, оставляет элементы при false
```
```php
$collection->first(); // Возвращает первый элемент коллекции
// При прокидывании closure возвращает первый элемент который соответствует условию
```
```php
$collection->last(); // Возвращает последний элемент коллекции
// При прокидывании closure возвращает последний элемент который соответствует условию
```
```php
$collection->firstOrFail(); // То же самое что first(), но при ненаходе выкидывает ItemNotFoundException
// Можно использовать для работы с try catch и выкидывать свои Exception'ы

$collection->firstWhere($key, $value); // То же самое, что и first, но можно сделать поиск без closure (для ассоциативных массивов)
```

```php
$collection->flatMap(); // Размепить ассоциативный массив (преобразовать, поменять ключи и т.п.)
// Возвращать в closure ВСЕГДА только массив
```
```php
$collection->flatten(optional $depth); // Преобразует вложенный массив в простой
// При указании $depth будет преобразовать только до определенной глубины
```
```php
$collection->flip(); // Меняет ключ и значение местами
```
```php
$collection->forget(); // Удаляет значение из массива по ключу
// Редактирует исходную коллекцию
```
```php
$collection->groupBy($key);
// Группирует вложенные элементы по ключу (например 'name') в новые коллекции
// с ключом значения ('Ivan' => Collection с объектами с 'name' => 'Ivan')
```
```php
$collection->implode($key, $separator); // Преобразует коллекцию в строку с заданным разделителем
// Работает на ассоциативных массивах
$collection->implode(function() {..}, $separator); // Перед преобразованием в строку каждый элемент можно
// изменить
```
```php
$collection->join(', ', 'and '); // То же самое, что и implode, только можно указать разделитель
для последнего и предпоследнего элемента
```
```php
$collection->keyBy(); // Позволяет пройтись по коллекции и присвоить каждому элементу ключ
// Можно указать ключ лежащего внутри коллекции массива,
// чтобы присвоить этому массиву ключ, который будет назван по значению ключа
$collection->keyBy(function() {...}); // Позволяет изменить название ключа
```
```php
$collection->lazy(); // Преобразует коллекцию в LazyCollection
```
```php
$collection->map(function($item) {...});
// Проходится по к коллекции и возвращает изменения из closure, в отличие от each
$collection->mapSpread(); // То же самое, что и eachSpread, но возвращает измененную коллекцию
// Должен приходить список с НЕ ассоциативными элементами
$collection->mapInto(SomeClass::class); // Преобразует элементы коллекции в заданный класс
$collection->mapToGroups(); // Группирует по ключ-значению какого-либо вложенного элемента
$collection->mapWithKeys(function() {...}); // Проходится по коллекции и возвращает новую с ключ-значениями
// указанными в closure (проверил эту же реализацию в map - создается доп вложенность)
```
```php
$collection->merge($collection2); // Объединяет коллекции или коллекцию с массивом
// При работе с ассоциативным массивом merge, в отличие от concat, заменит значения
// с одинаковыми ключами (возьмет из $collection2)
$collection->mergeRecursive($collection2) // Объединяет коллекции или коллекцию с массивом
// НЕ заменяет значения с одинаковыми ключами, а кладет их в подмассив
```
```php
$collection->nth($n); // Собирает новую коллекцию, пропуская элементы с заданным шагом
// Пример: Если шаг 3, возьмет 1, 4, 7... элементы в новую коллекцию
$collection->nth($n, $offset); // Можно указать $offset чтобы сдвинуть начало отсчета
```
```php
$collection->pad($count, $value); // Возвращает новую коллекцию, заполненную $count кол-вом элементов
// Если $count больше чем $collection->count(), то заполнит оставшиеся элементы значением $value
// Если хотим "дозаполнить" коллекцию не с конца, а с начала, то указываем отрицательный $count
```
```php
[$first, $second] = $collection->partition(function() {...});
// Возвращает два массива, в которые разбивает исходную коллекцию по определенному условию
// В коллекцию $first попадают элементы вернувшие true в closure
// Пример: Почистить коллекцию из чисел от строковых данных
```
```php
$collection->pipeThrough([
    function(Collection $collection) {...},
    function(Collection $collection) {...},
]); // Позволяет выполнить несколько замыканий над коллекцией подряд
// Может быть реализовано обычным chaining, но в разных компаниях требуют разные подходы
```
```php
$collection->pop($count); // Вырезает элементы из конца коллекции
// Вырезанные элементы пропадают из исходной коллекции
```
```php
$collection->prepend($item, $key); // Добавляет элемент в начало коллекции
// Опционально можно указать $key
```
```php
$collection->pull($key); // Вырезает элемент из коллекции по ключу
// Вырезанный элемент пропадает из исходной коллекции
```
```php
$collection->push(...$values); // Добавляет элементы в конец коллекции
// При добавлении элемента в ассоциативный массив ключи будут сгенерированы автоматически
```
```php
$collection->put($key, $value); // Добавляет элементы в конец коллекции
//Позволяет указать ключ при добавлении в ассоциативную коллекцию
```
```php
collect([])->range(1, 100); // Создает новую коллекцию и заполняет её
```
```php
$collection->reduce(function($carry, $value) {...}, $start); // Позволяет сложить какие-либо значения коллекции
//в $carry переменную (модифицируется на каждой итерации callback функции)
// Можно указать $start - начальное значение $carry
[$first, $second] = $collection->reduceSpread(function($even, $uneven, $value) {
    if ($value % 2 === 0) {
        $even += $value;
    } else {
        $uneven += $value;
    }
}); // То же самое что и reduce, но позволяет вернуть 2 переменные
```
```php
$collection->replace($collection2); // Работает как merge(), однако в дополнение к перезаписи совпадающих
// элементов, имеющих строковые ключи, метод replace также перезапишет элементы в коллекции, имеющие совпадающие
// цифровые ключи
$collection->replaceRecursive($collection2); // Работает как replace(), но будет повторяться во вложенных массивах
```
```php
$collection->reverse(); // Возвращает коллекцию в обратном порядке
```
```php
$collection->shift(int $n); // Вырезает $n элементов с начала массива
// Вырезанные элементы пропадают из коллекции
```
```php
$collection->shuffle(); // Возвращает коллекцию с разбросанными в рандомном порядке элементами
```
```php
$collection->skip(int $n); // Возвращает коллекцию без $n элементов с начала
$collection->skipUntil(function() {...}); // Можно прописать условие в closure для skip`а элементов
// Пропускает, пока условие НЕ соблюдается
$collection->skipWhile(function() {...}); // Можно прописать условие в closure для skip`а элементов
// Пропускает, пока условие соблюдается
```
```php
$collection->slice($skip, $offset); // То же самое, что и skip();
// $skip - сколько элементов пропустить от начала
// $offset - сколько элементов вернуть после пропущенных
```
```php
$collection->sliding(int $n, int $step); // Разбивает коллекцию на подколлекции с $n элементами
// $step - определяет шаг, с которым элементы будут класться в подколлекции
// Пример: при $step == 2, каждая подколлекция будет начинаться с того элемента,
// с которого закончилась предыдущая
```
```php
$collection->sort(); // Обычная сортировка
$collection->sortBy($key); // Сортировка по ключу
$collection->sortByDesc($key); // Сортировка по ключу по убыванию
$collection->sort(function() {...}); // Сортировка с closure, позволяет выполнить сложное условие для
// сортировки
// Пример: Сортировка по среднему значению одного из вложенных массивов или по сумме его элементов
```
```php
$collection->sortKeys(); // Сортировка по ключам
$collection->sortKeysUsing(); // What?
```
```php
$collection->splice($offset, $length);
// То же, что и slice, но в отличие от slice(), меняет исходную коллекцию
// Также, в отличие от slice, не сохраняет ключи элементов в новой коллекции
// Объяснение метода: вырезать $length элементов с $offset элемента $collection коллекции
// Третьим параметром можно указать массив элементов, которыми необходимо заменить вырезанные элементы
```
```php
$collection->split(int $n); // Разбивает коллекцию на заданное $n кол-во подколлекций
$collection->splitIn(int $n); // Разбивает коллекцию на заданное $n кол-во подколлекций
// В отличие от split(), сначала заполняет имеющиеся коллекции по ровну, после чего переходит к созданию
// следующей подколлекции (делит равномерно)
```
```php
$collection->toArray(); // Преобразование в массив
$collection->toJson(); // Преобразование в JSON
```
```php
$collection->transform(function() {...}); // То же, что и map(), но переопределяет исходную коллекцию
```
```php
$collection->undot(); // При наличии в коллекции ключей с точкой, преобразует вложенность коллекции
// согласно этим точкам
```
```php
$collection->union($collection2); // Объединяет коллекции, но добавляет только НЕ совпадающие ключи
// Не затирает значения ключей из первой коллекции значениями с такими же ключами во второй коллекции
```
```php
$collection->unless(bool $bool,
    function($collection, $value) {...},
    function($collection, $value) {...}
); // Выполняет closure при условии $bool
Выполняет первый closure при $bool = false
Выполняет второй closure при $bool = true
$value - значение $bool, прокидывается в closure на случай непредвиденных обстоятельств
```
```php
$collection->when(bool $bool,
    function($collection, $value) {...},
    function($collection, $value) {...}
); // Выполняет closure при условии $bool
Выполняет первый closure при $bool = true
Выполняет второй closure при $bool = false
$value - значение $bool, прокидывается в closure на случай непредвиденных обстоятельств
```
```php
$collection->unlessEmpty(
    function($collection, $value) {...},
    function($collection, $value) {...}
); // Выполняет один из closure в зависимости от состояния коллекции
Выполняет первый closure, если коллекция НЕ пуста
Выполняет второй closure, если коллекция пуста
```
```php
$collection->whenEmpty(
    function($collection, $value) {...},
    function($collection, $value) {...}
); // Выполняет один из closure в зависимости от состояния коллекции
Выполняет первый closure, если коллекция пуста
Выполняет второй closure, если коллекция НЕ пуста
```
```php
$collection->unlessNotEmpty(
    function($collection, $value) {...},
    function($collection, $value) {...}
); // = whenEmpty()
```
```php
$collection->whenNotEmpty(
    function($collection, $value) {...},
    function($collection, $value) {...}
); // = unlessEmpty()
```
```php
$collection->zip($collection2); // Соответственно соединит элементы $collection и $collection2
// создав подколлекции
// Если элементов в одной из коллекций не хватает, его парой в подколлекции будет null
```

### "Калькулирующие" функции

```php
$collection->average(); $collection->avg(); // Среднее значение в коллекции
$collection->max(); // Возвращает максимальное значение элемента в коллекции,
// можно в ассоциативных коллекциях по ключу
$collection->max(); // Возвращает минимальное значение элемента в коллекции,
// можно в ассоциативных коллекциях по ключу
$collection->median(); // Возвращает медианное значение коллекции
$collection->mode(); // Возвращает значение моды коллекции
$collection->sum(optional $key); // Суммирует элменты коллекции
// При необходимости можно добавить ключ, значения которого суммировать
```

## Создание собственного метода для Collection

Добавляем следующую реализацию в AppServiceProvider::boot
```php
Collection::macro('toUpper', function() {
    return $this->... // $this - коллекция, у которой вызван метод
    // У $this можно вызывать все остальные уже имеющиеся функции коллекций
});
```
## Статические функции класса Collection
> Есть более удобные аналоги
```php
Collection::make() // = collect()
Collection::unwrap($collection); // = $collection->toArray();
Collection::wrap($array); // = collect($array);
```

